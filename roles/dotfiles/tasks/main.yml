---
# Enhanced GNU Stow-based Dotfiles Deployment Role
# This role uses GNU Stow for proper symlink management of dotfiles
# CRITICAL: All stow commands MUST be executed from the correct working directory

- name: "GNU STOW DOTFILES DEPLOYMENT"
  debug:
    msg: "Deploying dotfiles using GNU Stow for {{ ansible_os_family }}"
  tags: ['dotfiles', 'banner']

# CRITICAL: Clean up incorrect nested structure first
- name: Remove nested config directory if it exists
  file:
    path: "{{ ansible_user_dir }}/.config/.config"
    state: absent
  register: nested_config_removal
  tags: ['dotfiles', 'cleanup', 'critical']

- name: Display nested config cleanup result
  debug:
    msg: "{{ 'Removed nested .config structure' if nested_config_removal.changed else 'No nested .config structure found' }}"
  tags: ['dotfiles', 'cleanup']

- name: Remove broken symlinks from config directory
  shell: |
    CONFIG_DIR="{{ ansible_user_dir }}/.config"
    if [ -d "$CONFIG_DIR" ]; then
      echo "Checking for broken symlinks in $CONFIG_DIR"
      # Find and remove broken symlinks
      find "$CONFIG_DIR" -maxdepth 2 -type l -exec test ! -e {} \; -delete 2>/dev/null || true
      echo "Broken symlinks cleanup completed"
    else
      echo "Config directory does not exist yet"
    fi
  args:
    executable: /bin/bash
  register: broken_links_cleanup
  changed_when: false
  tags: ['dotfiles', 'cleanup']

- name: Display critical cleanup results
  debug:
    msg: "{{ critical_cleanup.stdout_lines }}"
  when: critical_cleanup is defined
  tags: ['dotfiles', 'cleanup']

- name: Check if GNU Stow is installed
  shell: |
    # Check common stow locations
    if command -v stow >/dev/null 2>&1; then
      echo "stow found in PATH: $(which stow)"
      exit 0
    elif [ -x "/opt/homebrew/bin/stow" ]; then
      echo "stow found at: /opt/homebrew/bin/stow"
      exit 0
    elif [ -x "/usr/local/bin/stow" ]; then
      echo "stow found at: /usr/local/bin/stow"
      exit 0
    else
      echo "stow not found"
      exit 1
    fi
  register: stow_check
  failed_when: false
  changed_when: false
  tags: ['dotfiles', 'check']

- name: Set stow command path (cross-platform)
  set_fact:
    stow_command: >-
      {%- if ansible_os_family == 'Darwin' -%}
        {%- if ansible_architecture == 'arm64' -%}
          /opt/homebrew/bin/stow
        {%- else -%}
          /usr/local/bin/stow
        {%- endif -%}
      {%- else -%}
        stow
      {%- endif -%}
  when: stow_check.rc == 0
  tags: ['dotfiles', 'check']

- name: Display GNU Stow status
  debug:
    msg: "GNU Stow: {{ '‚úÖ INSTALLED' if stow_check.rc == 0 else '‚ùå MISSING' }}"
  tags: ['dotfiles', 'status']

- name: Install GNU Stow if missing (macOS)
  homebrew:
    name: stow
    state: present
  when:
    - ansible_os_family == "Darwin"
    - stow_check.rc != 0
  register: stow_install_result
  tags: ['dotfiles', 'install']

- name: Install GNU Stow if missing (Ubuntu/Debian)
  apt:
    name: stow
    state: present
    update_cache: yes
  become: yes
  when:
    - ansible_os_family == "Debian"
    - stow_check.rc != 0
  register: stow_install_result
  tags: ['dotfiles', 'install']

- name: Install GNU Stow if missing (Arch Linux)
  pacman:
    name: stow
    state: present
  become: yes
  when:
    - ansible_distribution == "Archlinux"
    - stow_check.rc != 0
  register: stow_install_result
  tags: ['dotfiles', 'install']

- name: Re-check GNU Stow after installation
  command: which stow
  register: stow_recheck
  failed_when: false
  changed_when: false
  when: stow_install_result is defined and stow_install_result.changed
  tags: ['dotfiles', 'check']

- name: Update stow_check result if installation succeeded
  set_fact:
    stow_check: "{{ stow_recheck }}"
  when:
    - stow_install_result is defined
    - stow_install_result.changed
    - stow_recheck is defined
  tags: ['dotfiles', 'check']

- name: Check if dotfiles source directory exists
  stat:
    path: "{{ dotfiles.local_path | default(playbook_dir + '/files/dotfiles') }}"
  register: dotfiles_source_check
  tags: ['dotfiles', 'check']

- name: Set dotfiles path variable
  set_fact:
    dotfiles_path: "{{ dotfiles.local_path | default(playbook_dir + '/files/dotfiles') }}"
  tags: ['dotfiles', 'setup']

- name: Display dotfiles source status
  debug:
    msg: "Dotfiles source: {{ '‚úÖ FOUND' if dotfiles_source_check.stat.exists else '‚ùå MISSING' }}: {{ dotfiles_path }}"
  tags: ['dotfiles', 'status']

- name: Create backup directory
  file:
    path: "{{ dotfiles.backup_directory | default(ansible_user_dir + '/.dotsible/backups') }}"
    state: directory
    mode: '0755'
  when: dotfiles_source_check.stat.exists
  tags: ['dotfiles', 'backup']

- name: Create .config directory if it doesn't exist
  file:
    path: "{{ ansible_user_dir }}/.config"
    state: directory
    mode: '0755'
  when: dotfiles_source_check.stat.exists
  tags: ['dotfiles', 'config']

- name: Discover available dotfiles applications
  find:
    paths: "{{ dotfiles_path }}"
    file_type: directory
    depth: 1
  register: available_dotfiles
  when: dotfiles_source_check.stat.exists
  tags: ['dotfiles', 'discovery']

- name: Set available applications list
  set_fact:
    dotfiles_apps: "{{ available_dotfiles.files | map(attribute='path') | map('basename') | list }}"
  when:
    - dotfiles_source_check.stat.exists
    - available_dotfiles is defined
  tags: ['dotfiles', 'discovery']

- name: Detect platform and window manager for conditional deployment
  set_fact:
    detected_platform: "{{ ansible_os_family }}"
    detected_display_server: "{{ 'x11' if ansible_env.DISPLAY is defined else 'none' }}"
    is_linux: "{{ ansible_os_family in ['Debian', 'RedHat', 'Archlinux'] }}"
    is_ubuntu: "{{ ansible_os_family == 'Debian' }}"
    is_macos: "{{ ansible_os_family == 'Darwin' }}"
    is_ssh_session: "{{ ansible_env.SSH_CLIENT is defined or ansible_env.SSH_TTY is defined }}"
  tags: ['dotfiles', 'discovery']

- name: Detect window manager (Linux only)
  shell: |
    # Try to detect the current window manager
    if [ -n "$XDG_CURRENT_DESKTOP" ]; then
      echo "$XDG_CURRENT_DESKTOP" | tr '[:upper:]' '[:lower:]'
    elif [ -n "$DESKTOP_SESSION" ]; then
      echo "$DESKTOP_SESSION" | tr '[:upper:]' '[:lower:]'
    elif pgrep -x "i3" >/dev/null; then
      echo "i3"
    elif pgrep -x "sway" >/dev/null; then
      echo "sway"
    elif pgrep -x "hyprland" >/dev/null; then
      echo "hyprland"
    elif pgrep -x "gnome-shell" >/dev/null; then
      echo "gnome"
    elif pgrep -x "plasmashell" >/dev/null; then
      echo "kde"
    else
      echo "unknown"
    fi
  register: window_manager_detection
  when: is_linux
  failed_when: false
  changed_when: false
  tags: ['dotfiles', 'discovery']

- name: Set detected window manager
  set_fact:
    detected_window_manager: "{{ window_manager_detection.stdout | default('unknown') if is_linux else 'none' }}"
    deploy_i3_apps: "{{ is_linux and (window_manager_detection.stdout | default('') == 'i3' or window_manager | default('auto') == 'i3' or ansible_env.XDG_CURRENT_DESKTOP | default('') | lower == 'i3') }}"
  tags: ['dotfiles', 'discovery']

- name: Filter applications for GNU Stow compatibility and platform
  set_fact:
    # Base applications available on all platforms
    base_apps: "{{ dotfiles_apps | select('match', '^(nvim|starship|alacritty|zsh|tmux|git|ranger|vim)$') | list }}"
    # i3 window manager specific applications (only when i3 is detected or requested)
    i3_apps: "{{ dotfiles_apps | select('match', '^(i3|polybar|rofi|picom|dunst)$') | list if deploy_i3_apps else [] }}"
    # General Linux applications (excluding i3-specific ones)
    linux_apps: "{{ dotfiles_apps | select('match', '^(compton)$') | list if is_linux else [] }}"
  when: dotfiles_apps is defined
  tags: ['dotfiles', 'discovery']

- name: Combine applications based on platform and window manager
  set_fact:
    stow_compatible_apps: "{{ base_apps + linux_apps + i3_apps }}"
  when: dotfiles_apps is defined
  tags: ['dotfiles', 'discovery']

- name: Display available applications
  debug:
    msg: |
      üì¶ Dotfiles Discovery Results:
      üñ•Ô∏è  Platform: {{ detected_platform }}
      üêß  Linux: {{ 'YES' if is_linux else 'NO' }}
      ü™ü  Display Server: {{ detected_display_server }}
      üéØ  Window Manager: {{ detected_window_manager }}
      üîß  Deploy i3 Apps: {{ 'YES' if deploy_i3_apps else 'NO' }}
      üì°  SSH Session: {{ 'YES' if is_ssh_session else 'NO' }}

      ‚Ä¢ Total applications found: {{ dotfiles_apps | length if dotfiles_apps is defined else 0 }}
      ‚Ä¢ All applications: {{ dotfiles_apps | join(', ') if dotfiles_apps is defined else 'None' }}
      ‚Ä¢ Base applications: {{ base_apps | join(', ') if base_apps is defined else 'None' }}
      {% if is_linux %}
      ‚Ä¢ Linux-specific apps: {{ linux_apps | join(', ') if linux_apps is defined else 'None' }}
      {% endif %}
      {% if deploy_i3_apps %}
      ‚Ä¢ i3 window manager apps: {{ i3_apps | join(', ') if i3_apps is defined else 'None' }}
      {% endif %}
      ‚Ä¢ Will deploy: {{ stow_compatible_apps | join(', ') if stow_compatible_apps is defined else 'None' }}
      ‚Ä¢ Total to deploy: {{ stow_compatible_apps | length if stow_compatible_apps is defined else 0 }} applications
  when: dotfiles_apps is defined
  tags: ['dotfiles', 'discovery']

# CRITICAL: Handle Oh-My-Zsh symlink conflicts before stow deployment
- name: Check for Oh-My-Zsh backup files that interfere with stow
  stat:
    path: "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh"
  register: zshrc_pre_oh_my_zsh_check
  tags: ['dotfiles', 'zsh', 'conflicts']

- name: Remove incorrect Oh-My-Zsh symlink that blocks stow
  file:
    path: "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh"
    state: absent
  when:
    - zshrc_pre_oh_my_zsh_check.stat.exists
    - zshrc_pre_oh_my_zsh_check.stat.islnk | default(false)
  tags: ['dotfiles', 'zsh', 'cleanup']

- name: Check for existing .zshrc that might conflict with stow
  stat:
    path: "{{ ansible_user_dir }}/.zshrc"
  register: existing_zshrc_check
  tags: ['dotfiles', 'zsh', 'conflicts']

- name: Backup existing .zshrc if it's not a symlink
  copy:
    src: "{{ ansible_user_dir }}/.zshrc"
    dest: "{{ ansible_user_dir }}/.zshrc.backup.{{ ansible_date_time.epoch }}"
    remote_src: yes
  when:
    - existing_zshrc_check.stat.exists
    - not (existing_zshrc_check.stat.islnk | default(false))
  tags: ['dotfiles', 'zsh', 'backup']

- name: Remove non-symlink .zshrc to allow stow deployment
  file:
    path: "{{ ansible_user_dir }}/.zshrc"
    state: absent
  when:
    - existing_zshrc_check.stat.exists
    - not (existing_zshrc_check.stat.islnk | default(false))
  tags: ['dotfiles', 'zsh', 'cleanup']

# Backup existing files before stow deployment
- name: Check for existing dotfiles that would conflict
  shell: |
    cd "{{ dotfiles_path }}"
    for app in {{ dotfiles_apps | join(' ') }}; do
      if [ -d "$app" ]; then
        echo "Checking conflicts for $app..."
        {{ stow_command | default('stow') }} --no --target="{{ ansible_user_dir }}" "$app" 2>&1 | grep -E "(existing|conflict)" || true
      fi
    done
  args:
    executable: /bin/bash
  register: stow_conflicts
  when:
    - dotfiles_source_check.stat.exists
    - stow_check.rc == 0
    - dotfiles_apps is defined
  changed_when: false
  failed_when: false
  tags: ['dotfiles', 'conflicts']

- name: Display conflict analysis
  debug:
    msg: "{{ stow_conflicts.stdout_lines }}"
  when:
    - stow_conflicts is defined
    - stow_conflicts.stdout_lines | length > 0
  tags: ['dotfiles', 'conflicts']

- name: Backup conflicting files
  shell: |
    backup_dir="{{ dotfiles.backup_directory | default(ansible_user_dir + '/.dotsible/backups') }}"
    timestamp=$(date +%Y%m%d-%H%M%S)

    # Common files that might conflict
    for file in .zshrc .gitconfig .tmux.conf; do
      if [ -f "{{ ansible_user_dir }}/$file" ] && [ ! -L "{{ ansible_user_dir }}/$file" ]; then
        echo "Backing up existing $file"
        cp "{{ ansible_user_dir }}/$file" "$backup_dir/$file.$timestamp.bak"
      fi
    done

    # Config directories that might conflict
    for dir in nvim starship alacritty; do
      if [ -d "{{ ansible_user_dir }}/.config/$dir" ] && [ ! -L "{{ ansible_user_dir }}/.config/$dir" ]; then
        echo "Backing up existing .config/$dir"
        tar -czf "$backup_dir/config-$dir.$timestamp.tar.gz" -C "{{ ansible_user_dir }}/.config" "$dir" 2>/dev/null || true
      fi
    done
  args:
    executable: /bin/bash
  register: backup_result
  when:
    - dotfiles_source_check.stat.exists
    - dotfiles.backup_existing | default(true) | bool
  changed_when: backup_result.stdout != ""
  tags: ['dotfiles', 'backup']

- name: Display backup results
  debug:
    msg: "{{ backup_result.stdout_lines }}"
  when:
    - backup_result is defined
    - backup_result.stdout_lines | length > 0
  tags: ['dotfiles', 'backup']

# Clean up inconsistent symlinks before deployment
- name: Clean up inconsistent symlinks and files
  shell: |
    echo "üßπ Cleaning up inconsistent symlinks and files..."

    # Remove symlinks pointing to wrong paths (dotsible instead of dotfiles)
    for item in "{{ ansible_user_dir }}/.config/git" "{{ ansible_user_dir }}/.gitconfig"; do
      if [ -L "$item" ]; then
        target=$(readlink "$item")
        if [[ "$target" == *"/dotsible/"* ]]; then
          echo "Removing incorrect symlink: $item ‚Üí $target"
          rm "$item"
        fi
      fi
    done

    # Remove regular files that should be symlinks
    for item in "{{ ansible_user_dir }}/.config/starship.toml" "{{ ansible_user_dir }}/.zshrc" "{{ ansible_user_dir }}/.tmux.conf"; do
      if [ -f "$item" ] && [ ! -L "$item" ]; then
        echo "Removing regular file (should be symlink): $item"
        mv "$item" "$item.backup.$(date +%s)"
      fi
    done

    # CRITICAL: Handle Oh-My-Zsh backup file conflicts
    # Oh-My-Zsh installation may rename .zshrc to .zshrc.pre-oh-my-zsh
    if [ -L "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh" ]; then
      echo "Found Oh-My-Zsh backup symlink: .zshrc.pre-oh-my-zsh"
      if [ ! -e "{{ ansible_user_dir }}/.zshrc" ]; then
        echo "Moving .zshrc.pre-oh-my-zsh back to .zshrc"
        mv "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh" "{{ ansible_user_dir }}/.zshrc"
      else
        echo "Removing duplicate .zshrc.pre-oh-my-zsh symlink"
        rm "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh"
      fi
    fi

    # Remove any broken symlinks that point to non-existent dotfiles
    find "{{ ansible_user_dir }}" -maxdepth 2 -type l -exec test ! -e {} \; -print0 2>/dev/null | while IFS= read -r -d '' broken_link; do
      target=$(readlink "$broken_link")
      if [[ "$target" == *"dotfiles"* ]]; then
        echo "Removing broken dotfiles symlink: $broken_link ‚Üí $target"
        rm "$broken_link"
      fi
    done

    # Clean up backup file pollution
    echo "Cleaning up backup files..."
    find ~ -maxdepth 1 -name ".zshrc.*~" -type f | head -20 | while read file; do
      echo "Removing backup: $file"
      rm "$file"
    done

    echo "‚úÖ Cleanup completed"
  args:
    executable: /bin/bash
  register: cleanup_result
  when:
    - dotfiles_source_check.stat.exists
    - stow_check.rc == 0
  changed_when: "'Removing' in cleanup_result.stdout"
  tags: ['dotfiles', 'cleanup']

- name: Display cleanup results
  debug:
    msg: "{{ cleanup_result.stdout_lines }}"
  when:
    - cleanup_result is defined
    - cleanup_result.stdout_lines is defined
    - cleanup_result.stdout_lines | length > 0
  tags: ['dotfiles', 'cleanup']

# GNU Stow deployment with proper working directory
- name: Set stow deployment variables
  set_fact:
    stow_target: "{{ ansible_user_dir }}"
    stow_flags: "{{ '--restow' if dotfiles.symlink_strategy | default('force') == 'force' else '' }}"
    stow_strategy: "{{ dotfiles.symlink_strategy | default('force') }}"
  when:
    - dotfiles_source_check.stat.exists
    - stow_check.rc == 0
    - dotfiles_apps is defined
  tags: ['dotfiles', 'deploy']

# CRITICAL: Ensure we have the exact correct working directory
- name: "CRITICAL - Verify correct stow root directory"
  shell: |
    STOW_ROOT="{{ dotfiles_path }}"

    echo "Verifying stow root directory..."
    echo "Stow root: $STOW_ROOT"
    echo "Platform: {{ ansible_os_family }}"

    if [ ! -d "$STOW_ROOT" ]; then
      echo "CRITICAL ERROR: Stow root directory does not exist: $STOW_ROOT"
      exit 1
    fi

    cd "$STOW_ROOT"
    echo "Working directory verified: $(pwd)"

    echo "Available applications in stow root:"
    for app in */; do
      if [ -d "$app" ]; then
        app_name=$(basename "$app")
        echo "  - $app_name"

        # Check structure
        if [ -d "$app/.config" ]; then
          echo "    -> .config/ structure (correct for stow)"
        elif [ -f "$app/.${app_name}rc" ] || [ -f "$app/.${app_name}.conf" ]; then
          echo "    -> direct file structure (correct for stow)"
        else
          echo "    -> unknown structure"
        fi
      fi
    done
  args:
    executable: /bin/bash
  register: stow_root_verification
  failed_when: stow_root_verification.rc != 0
  tags: ['dotfiles', 'verify', 'critical']

- name: Display stow root verification
  debug:
    msg: "{{ stow_root_verification.stdout_lines }}"
  tags: ['dotfiles', 'verify']

# CRITICAL: Deploy each application with ABSOLUTE working directory control
- name: "CRITICAL - Deploy applications with GNU Stow from correct directory"
  shell: |
    # Use the dynamically determined dotfiles path
    STOW_ROOT="{{ dotfiles_path }}"
    TARGET_DIR="{{ ansible_user_dir }}"
    APP="{{ item }}"

    echo "Deploying $APP with GNU Stow..."
    echo "   Stow root: $STOW_ROOT"
    echo "   Target: $TARGET_DIR"
    echo "   Platform: {{ ansible_os_family }}"
    echo "   Working directory: $(pwd)"

    # CRITICAL: Change to the exact stow root directory
    cd "$STOW_ROOT" || {
      echo "FAILED: Cannot change to stow root: $STOW_ROOT"
      echo "STATUS:FAILED"
      exit 0
    }

    echo "   Changed to: $(pwd)"

    # Verify application directory exists
    if [ ! -d "$APP" ]; then
      echo "FAILED: $APP directory not found in $(pwd)"
      echo "STATUS:FAILED"
      exit 0
    fi

    # Use the correct stow command path with cross-platform fallback
    STOW_CMD="{{ stow_command | default('stow') }}"

    # Cross-platform stow command detection
    if ! [ -x "$STOW_CMD" ]; then
      echo "   Primary stow command not found: $STOW_CMD"
      # Try common locations
      for stow_path in /opt/homebrew/bin/stow /usr/local/bin/stow /usr/bin/stow $(which stow 2>/dev/null); do
        if [ -x "$stow_path" ]; then
          STOW_CMD="$stow_path"
          echo "   Found stow at: $STOW_CMD"
          break
        fi
      done
    fi

    # Final verification that stow is available
    if ! [ -x "$STOW_CMD" ]; then
      echo "FAILED: GNU Stow not available at any known location"
      echo "STATUS:FAILED"
      exit 0
    fi

    echo "   Application structure:"
    find "$APP" -type f | head -3 | sed 's/^/     /'

    # Remove any existing broken symlinks for this app
    if [ -L "$TARGET_DIR/.config/$APP" ] && [ ! -e "$TARGET_DIR/.config/$APP" ]; then
      echo "   Removing broken symlink: ~/.config/$APP"
      rm "$TARGET_DIR/.config/$APP"
    fi

    # Check current stow status
    echo "   Checking current stow status..."
    stow_dry_output=$($STOW_CMD --no --target="$TARGET_DIR" "$APP" 2>&1)
    stow_dry_rc=$?

    echo "   Dry run output: $stow_dry_output"

    if echo "$stow_dry_output" | grep -q "already stowed"; then
      echo "SKIPPED: $APP (already properly stowed)"
      echo "STATUS:SKIPPED"
    elif echo "$stow_dry_output" | grep -q "No conflicts" || [ $stow_dry_rc -eq 0 ]; then
      # Deploy with stow using explicit target directory
      echo "   Executing: $STOW_CMD --target=$TARGET_DIR --restow $APP"
      if $STOW_CMD --target="$TARGET_DIR" --restow "$APP" 2>&1; then
        echo "DEPLOYED: $APP"
        echo "STATUS:DEPLOYED"

        # Verify the deployment with cross-platform compatibility
        if [ -d "$APP/.config" ]; then
          for config_item in "$APP/.config"/*; do
            if [ -e "$config_item" ]; then
              config_name=$(basename "$config_item")
              if [ -L "$TARGET_DIR/.config/$config_name" ]; then
                target=$(readlink "$TARGET_DIR/.config/$config_name")
                echo "   Verified: ~/.config/$config_name -> $target"
              fi
            fi
          done
        fi

        # Special verification for root-level dotfiles (zsh, tmux, git)
        for root_file in .zshrc .zprofile .tmux.conf .gitconfig; do
          if [ -f "$APP/$root_file" ]; then
            if [ -L "$TARGET_DIR/$root_file" ]; then
              target=$(readlink "$TARGET_DIR/$root_file")
              echo "   Verified: ~/$root_file -> $target"
            else
              echo "   WARNING: ~/$root_file is not a symlink (expected for $APP)"
            fi
          fi
        done

        # Check for direct home files
        for home_file in "$APP"/.*; do
          if [ -f "$home_file" ] && [[ $(basename "$home_file") != .* ]]; then
            file_name=$(basename "$home_file")
            if [ -L "$TARGET_DIR/$file_name" ]; then
              target=$(readlink "$TARGET_DIR/$file_name")
              echo "   Verified: ~/$file_name -> $target"
            fi
          fi
        done

      else
        echo "FAILED: $APP (stow command failed)"
        echo "STATUS:FAILED"
      fi
    else
      echo "FAILED: $APP (conflicts exist)"
      echo "   Conflicts: $stow_dry_output"
      echo "STATUS:FAILED"
    fi
  args:
    executable: /bin/bash
  register: stow_deployment_results
  loop: "{{ stow_compatible_apps | default(['nvim', 'zsh', 'starship', 'alacritty', 'tmux']) }}"
  when:
    - dotfiles_source_check.stat.exists
    - stow_check.rc == 0
  changed_when: "'STATUS:DEPLOYED' in stow_deployment_results.stdout"
  failed_when: false
  tags: ['dotfiles', 'deploy', 'critical']

- name: Collect deployment results
  set_fact:
    deployed_apps: "{{ stow_deployment_results.results | selectattr('stdout', 'search', 'STATUS:DEPLOYED') | map(attribute='item') | list }}"
    adopted_apps: "{{ stow_deployment_results.results | selectattr('stdout', 'search', 'STATUS:ADOPTED') | map(attribute='item') | list }}"
    skipped_apps: "{{ stow_deployment_results.results | selectattr('stdout', 'search', 'STATUS:SKIPPED') | map(attribute='item') | list }}"
    failed_apps: "{{ stow_deployment_results.results | selectattr('stdout', 'search', 'STATUS:FAILED') | map(attribute='item') | list }}"
  when: stow_deployment_results is defined
  tags: ['dotfiles', 'deploy']

- name: Display deployment results
  debug:
    msg: |
      üîó GNU Stow Deployment Results:
      {% if deployed_apps | length > 0 %}
      ‚úÖ DEPLOYED: {{ deployed_apps | join(', ') }}
      {% endif %}
      {% if adopted_apps | length > 0 %}
      üîÑ ADOPTED: {{ adopted_apps | join(', ') }}
      {% endif %}
      {% if skipped_apps | length > 0 %}
      ‚è≠Ô∏è SKIPPED: {{ skipped_apps | join(', ') }}
      {% endif %}
      {% if failed_apps | length > 0 %}
      ‚ùå FAILED: {{ failed_apps | join(', ') }}
      {% endif %}
  when: stow_app_results is defined
  tags: ['dotfiles', 'deploy']

# Verification of deployed symlinks
# CRITICAL: Comprehensive verification of actual filesystem state
- name: "CRITICAL - Verify actual symlink structure and detect issues"
  shell: |
    echo "CRITICAL VERIFICATION: Checking actual filesystem state..."
    echo ""

    STOW_ROOT="{{ dotfiles_path }}"
    verified_count=0
    missing_count=0
    wrong_count=0

    echo "Expected symlink structure for {{ ansible_os_family }}:"
    echo "  ~/.config/nvim -> $STOW_ROOT/nvim/.config/nvim"
    echo "  ~/.config/alacritty -> $STOW_ROOT/alacritty/.config/alacritty"
    echo "  ~/.config/starship.toml -> $STOW_ROOT/starship/.config/starship.toml"
    echo "  ~/.zshrc -> $STOW_ROOT/zsh/.zshrc"
    {% if ansible_os_family == "Debian" %}
    echo "  ~/.config/i3 -> $STOW_ROOT/i3/.config/i3"
    echo "  ~/.config/polybar -> $STOW_ROOT/polybar/.config/polybar"
    echo "  ~/.config/rofi -> $STOW_ROOT/rofi/.config/rofi"
    {% endif %}
    echo ""

    echo "Actual filesystem state:"

    # Check ~/.config/nvim
    if [ -L "{{ ansible_user_dir }}/.config/nvim" ] && [ -e "{{ ansible_user_dir }}/.config/nvim" ]; then
      target=$(readlink "{{ ansible_user_dir }}/.config/nvim")
      echo "CORRECT: ~/.config/nvim -> $target"
      verified_count=$((verified_count + 1))
    elif [ -L "{{ ansible_user_dir }}/.config/nvim" ]; then
      target=$(readlink "{{ ansible_user_dir }}/.config/nvim")
      echo "BROKEN: ~/.config/nvim -> $target (symlink exists but target missing)"
      wrong_count=$((wrong_count + 1))
    elif [ -d "{{ ansible_user_dir }}/.config/nvim" ]; then
      echo "NOT_SYMLINK: ~/.config/nvim is a directory (should be symlink)"
      wrong_count=$((wrong_count + 1))
    else
      echo "MISSING: ~/.config/nvim does not exist"
      missing_count=$((missing_count + 1))
    fi

    # Check ~/.config/alacritty
    if [ -L "{{ ansible_user_dir }}/.config/alacritty" ]; then
      target=$(readlink "{{ ansible_user_dir }}/.config/alacritty")
      expected="$STOW_ROOT/alacritty/.config/alacritty"
      if [ "$target" = "$expected" ]; then
        echo "CORRECT: ~/.config/alacritty -> $target"
        verified_count=$((verified_count + 1))
      else
        echo "WRONG_TARGET: ~/.config/alacritty -> $target (expected: $expected)"
        wrong_count=$((wrong_count + 1))
      fi
    else
      echo "MISSING: ~/.config/alacritty does not exist or is not a symlink"
      missing_count=$((missing_count + 1))
    fi

    # Check ~/.config/starship.toml
    if [ -L "{{ ansible_user_dir }}/.config/starship.toml" ]; then
      target=$(readlink "{{ ansible_user_dir }}/.config/starship.toml")
      expected="$STOW_ROOT/starship/.config/starship.toml"
      if [ "$target" = "$expected" ]; then
        echo "CORRECT: ~/.config/starship.toml -> $target"
        verified_count=$((verified_count + 1))
      else
        echo "WRONG_TARGET: ~/.config/starship.toml -> $target (expected: $expected)"
        wrong_count=$((wrong_count + 1))
      fi
    elif [ -f "{{ ansible_user_dir }}/.config/starship.toml" ]; then
      echo "NOT_SYMLINK: ~/.config/starship.toml is a regular file (should be symlink)"
      wrong_count=$((wrong_count + 1))
    else
      echo "MISSING: ~/.config/starship.toml does not exist"
      missing_count=$((missing_count + 1))
    fi

    # Check ~/.zshrc
    if [ -L "{{ ansible_user_dir }}/.zshrc" ]; then
      target=$(readlink "{{ ansible_user_dir }}/.zshrc")
      expected="$STOW_ROOT/zsh/.zshrc"
      if [ "$target" = "$expected" ]; then
        echo "CORRECT: ~/.zshrc -> $target"
        verified_count=$((verified_count + 1))
      else
        echo "WRONG_TARGET: ~/.zshrc -> $target (expected: $expected)"
        wrong_count=$((wrong_count + 1))
      fi
    elif [ -f "{{ ansible_user_dir }}/.zshrc" ]; then
      echo "NOT_SYMLINK: ~/.zshrc is a regular file (should be symlink)"
      wrong_count=$((wrong_count + 1))
    else
      echo "MISSING: ~/.zshrc does not exist"
      missing_count=$((missing_count + 1))
    fi

    echo ""
    echo "Checking for problematic nested structures:"
    if [ -d "{{ ansible_user_dir }}/.config/.config" ]; then
      echo "CRITICAL: Nested .config structure still exists: ~/.config/.config/"
      ls -la "{{ ansible_user_dir }}/.config/.config/" | head -5
      wrong_count=$((wrong_count + 1))
    else
      echo "No nested .config structure found"
    fi

    echo ""
    echo "VERIFICATION SUMMARY:"
    echo "Correct symlinks: $verified_count"
    echo "Missing: $missing_count"
    echo "Wrong/Broken: $wrong_count"
    echo "Total expected: 4"

    if [ $verified_count -eq 4 ] && [ $missing_count -eq 0 ] && [ $wrong_count -eq 0 ]; then
      echo "DEPLOYMENT SUCCESS: All symlinks are correct!"
      echo "VERIFICATION_STATUS:SUCCESS"
    else
      echo "DEPLOYMENT ISSUES: Some symlinks are missing or incorrect"
      echo "VERIFICATION_STATUS:FAILED"
    fi
  args:
    executable: /bin/bash
  register: critical_verification
  when: stow_deployment_results is defined
  changed_when: false
  tags: ['dotfiles', 'verify', 'critical']

- name: Display critical verification results
  debug:
    msg: "{{ critical_verification.stdout_lines }}"
  when:
    - critical_verification is defined
    - critical_verification.stdout_lines is defined
    - critical_verification.stdout_lines | length > 0
  tags: ['dotfiles', 'verify']

# CRITICAL: Post-deployment fixes for common symlink issues
- name: Fix critical symlink issues discovered during verification
  shell: |
    echo "üîß FIXING CRITICAL SYMLINK ISSUES"
    echo "=================================="

    fixed_count=0

    # CRITICAL: Fix Oh-My-Zsh symlink conflicts
    if [ -L "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh" ] && [ ! -L "{{ ansible_user_dir }}/.zshrc" ]; then
      echo "üîß Fixing Oh-My-Zsh symlink conflict (.zshrc.pre-oh-my-zsh -> .zshrc)..."
      target=$(readlink "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh")
      rm "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh"
      ln -sf "$target" "{{ ansible_user_dir }}/.zshrc"
      echo "   ‚úÖ Fixed: .zshrc now points to $target"
      fixed_count=$((fixed_count + 1))
    fi

    # Fix ZSH configuration symlink issues
    if [ ! -L "{{ ansible_user_dir }}/.zshrc" ] || [ ! -e "{{ ansible_user_dir }}/.zshrc" ]; then
      echo "üîß Fixing ZSH configuration symlink..."

      # Remove any existing non-symlink .zshrc
      if [ -f "{{ ansible_user_dir }}/.zshrc" ] && [ ! -L "{{ ansible_user_dir }}/.zshrc" ]; then
        echo "   Backing up existing .zshrc"
        cp "{{ ansible_user_dir }}/.zshrc" "{{ ansible_user_dir }}/.zshrc.backup.{{ ansible_date_time.epoch }}"
        rm -f "{{ ansible_user_dir }}/.zshrc"
      fi

      # Remove incorrect Oh-My-Zsh symlink
      if [ -L "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh" ]; then
        echo "   Removing incorrect .zshrc.pre-oh-my-zsh symlink"
        rm -f "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh"
      fi

      # Create correct symlink
      if [ -f "{{ dotfiles_path }}/zsh/.zshrc" ]; then
        echo "   Creating correct .zshrc symlink"
        ln -sf "{{ dotfiles_path }}/zsh/.zshrc" "{{ ansible_user_dir }}/.zshrc"
        echo "‚úÖ Fixed: ~/.zshrc -> {{ dotfiles_path }}/zsh/.zshrc"
        fixed_count=$((fixed_count + 1))
      else
        echo "‚ùå Error: Source file {{ dotfiles_path }}/zsh/.zshrc not found"
      fi
    else
      echo "‚úÖ ZSH: ~/.zshrc symlink is correct"
    fi

    # Fix tmux configuration symlink issues using proper stow deployment
    if [ ! -L "{{ ansible_user_dir }}/.tmux.conf" ] || [ ! -e "{{ ansible_user_dir }}/.tmux.conf" ]; then
      echo "üîß Fixing tmux configuration symlink using stow..."

      # Remove any existing non-symlink .tmux.conf
      if [ -f "{{ ansible_user_dir }}/.tmux.conf" ] && [ ! -L "{{ ansible_user_dir }}/.tmux.conf" ]; then
        echo "   Backing up existing .tmux.conf"
        cp "{{ ansible_user_dir }}/.tmux.conf" "{{ ansible_user_dir }}/.tmux.conf.backup.{{ ansible_date_time.epoch }}"
        rm -f "{{ ansible_user_dir }}/.tmux.conf"
      fi

      # Use stow to create correct symlink with proper target directory
      if [ -f "{{ dotfiles_path }}/tmux/.tmux.conf" ]; then
        echo "   Creating .tmux.conf symlink using stow with target={{ ansible_user_dir }}"
        cd "{{ dotfiles_path }}"
        if {{ stow_command | default('stow') }} --target="{{ ansible_user_dir }}" --restow tmux 2>&1; then
          echo "‚úÖ Fixed: ~/.tmux.conf symlink created via stow"
          fixed_count=$((fixed_count + 1))
        else
          echo "‚ö†Ô∏è  Stow failed, falling back to direct symlink creation"
          ln -sf "{{ dotfiles_path }}/tmux/.tmux.conf" "{{ ansible_user_dir }}/.tmux.conf"
          echo "‚úÖ Fixed: ~/.tmux.conf -> {{ dotfiles_path }}/tmux/.tmux.conf"
          fixed_count=$((fixed_count + 1))
        fi
      else
        echo "‚ùå Error: Source file {{ dotfiles_path }}/tmux/.tmux.conf not found"
      fi
    else
      echo "‚úÖ TMUX: ~/.tmux.conf symlink is correct"
    fi

    echo ""
    echo "üìã SYMLINK FIX SUMMARY:"
    echo "Fixed symlinks: $fixed_count"

    if [ $fixed_count -gt 0 ]; then
      echo "SYMLINK_FIXES:APPLIED"
    else
      echo "SYMLINK_FIXES:NONE_NEEDED"
    fi

    echo ""
    echo "üìã FINAL SYMLINK STATUS:"
    ls -la "{{ ansible_user_dir }}" | grep -E "(\.zshrc|\.tmux\.conf)" | grep -v backup || echo "No relevant symlinks found"
  args:
    executable: /bin/bash
  register: symlink_fix_result
  when:
    - critical_verification is defined
    - "'VERIFICATION_STATUS:FAILED' in critical_verification.stdout"
  changed_when: "'SYMLINK_FIXES:APPLIED' in symlink_fix_result.stdout"
  tags: ['dotfiles', 'fix', 'critical']

- name: Display symlink fix results
  debug:
    msg: "{{ symlink_fix_result.stdout_lines }}"
  when:
    - symlink_fix_result is defined
    - symlink_fix_result.stdout_lines is defined
  tags: ['dotfiles', 'fix']

# Final deployment summary
- name: Generate deployment summary
  set_fact:
    dotfiles_summary:
      source_path: "{{ dotfiles_path }}"
      available_apps: "{{ dotfiles_apps | length if dotfiles_apps is defined else 0 | int }}"
      stow_available: "{{ stow_check.rc == 0 }}"
      deployment_successful: "{{ stow_app_results is defined and (deployed_apps | default([]) | length > 0 or adopted_apps | default([]) | length > 0) }}"
      backup_directory: "{{ dotfiles.backup_directory | default(ansible_user_dir + '/.dotsible/backups') }}"
      total_deployed: "{{ ((deployed_apps | default([]) | length) + (adopted_apps | default([]) | length)) | int }}"
      total_skipped: "{{ (skipped_apps | default([]) | length) | int }}"
      total_failed: "{{ (failed_apps | default([]) | length) | int }}"
      validation_passed: "{{ dotfiles_validation_passed | default(false) }}"
      critical_issues: "{{ dotfiles_critical_issues | default(0) }}"
      warnings: "{{ dotfiles_warnings | default(0) }}"
  tags: ['dotfiles', 'summary']

- name: Display final dotfiles deployment summary
  debug:
    msg: |
      üîó GNU Stow Dotfiles Deployment Summary:

      üìÇ Source: {{ dotfiles_summary.source_path }}
      üîß GNU Stow: {{ '‚úÖ AVAILABLE' if dotfiles_summary.stow_available else '‚ùå MISSING' }}
      üì¶ Applications: {{ dotfiles_summary.available_apps }} found
      üöÄ Deployment: {{ '‚úÖ SUCCESSFUL' if dotfiles_summary.deployment_successful else '‚ùå FAILED' }}
      üìä Results: {{ dotfiles_summary.total_deployed }} deployed, {{ dotfiles_summary.total_skipped }} skipped, {{ dotfiles_summary.total_failed }} failed
      üõ°Ô∏è Backups: {{ dotfiles_summary.backup_directory }}

      üîç Validation: {{ '‚úÖ PASSED' if dotfiles_summary.validation_passed else '‚ùå FAILED' }}
      {% if dotfiles_summary.critical_issues | int > 0 %}
      ‚ùå Critical Issues: {{ dotfiles_summary.critical_issues }}
      {% endif %}
      {% if dotfiles_summary.warnings | int > 0 %}
      ‚ö†Ô∏è Warnings: {{ dotfiles_summary.warnings }}
      {% endif %}

      {% if dotfiles_summary.total_deployed | int > 0 %}
      üîÑ Dotfiles were updated - restart your shell to apply changes
      {% endif %}

      {% if not dotfiles_summary.validation_passed %}

      üîß Troubleshooting:
      ‚Ä¢ Check symlinks: ls -la ~/.zshrc ~/.tmux.conf ~/.config/starship.toml
      ‚Ä¢ Verify targets exist: ls -la {{ dotfiles_path }}/zsh/.zshrc {{ dotfiles_path }}/tmux/.tmux.conf
      ‚Ä¢ Re-run deployment: ansible-playbook site.yml --tags dotfiles
      {% endif %}

      üí° Manual GNU Stow operations:
      cd {{ dotfiles_path }} && stow --target={{ ansible_user_dir }} --restow zsh tmux starship
      cd {{ dotfiles_path }} && stow --target={{ ansible_user_dir }} --dry-run --verbose <app>
      cd {{ dotfiles_path }} && stow --target={{ ansible_user_dir }} --delete <app>
  tags: ['dotfiles', 'summary']

# FINAL VALIDATION: Comprehensive post-deployment validation
- name: "FINAL VALIDATION - Verify all critical symlinks are working"
  shell: |
    echo "üîç FINAL VALIDATION: Comprehensive symlink verification"
    echo "======================================================"

    validation_passed=true
    critical_issues=0
    warnings=0

    # Define critical symlinks that must exist and work
    declare -A critical_symlinks=(
      ["{{ ansible_user_dir }}/.zshrc"]="{{ dotfiles_path }}/zsh/.zshrc"
      ["{{ ansible_user_dir }}/.zprofile"]="{{ dotfiles_path }}/zsh/.zprofile"
      ["{{ ansible_user_dir }}/.tmux.conf"]="{{ dotfiles_path }}/tmux/.tmux.conf"
      ["{{ ansible_user_dir }}/.config/starship.toml"]="{{ dotfiles_path }}/starship/.config/starship.toml"
    )

    echo "Checking critical symlinks:"
    for symlink_path in "${!critical_symlinks[@]}"; do
      expected_target="${critical_symlinks[$symlink_path]}"

      if [ -L "$symlink_path" ]; then
        actual_target=$(readlink "$symlink_path")
        if [ -e "$symlink_path" ]; then
          if [[ "$actual_target" == *"$(basename "$expected_target")" ]]; then
            echo "‚úÖ $symlink_path -> $actual_target (VALID)"
          else
            echo "‚ö†Ô∏è  $symlink_path -> $actual_target (UNEXPECTED TARGET)"
            warnings=$((warnings + 1))
          fi
        else
          echo "‚ùå $symlink_path -> $actual_target (BROKEN - target missing)"
          critical_issues=$((critical_issues + 1))
          validation_passed=false
        fi
      elif [ -f "$symlink_path" ]; then
        echo "‚ùå $symlink_path (REGULAR FILE - should be symlink)"
        critical_issues=$((critical_issues + 1))
        validation_passed=false
      else
        echo "‚ùå $symlink_path (MISSING)"
        critical_issues=$((critical_issues + 1))
        validation_passed=false
      fi
    done

    # Check for Oh-My-Zsh conflicts
    echo ""
    echo "Checking for Oh-My-Zsh conflicts:"
    if [ -f "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh" ]; then
      echo "‚ö†Ô∏è  .zshrc.pre-oh-my-zsh backup file exists"
      warnings=$((warnings + 1))
    fi

    if [ -L "{{ ansible_user_dir }}/.zshrc.pre-oh-my-zsh" ]; then
      echo "‚ùå .zshrc.pre-oh-my-zsh symlink exists (should be .zshrc)"
      critical_issues=$((critical_issues + 1))
      validation_passed=false
    fi

    # Test ZSH configuration loading
    echo ""
    echo "Testing ZSH configuration:"
    if [ -L "{{ ansible_user_dir }}/.zshrc" ] && [ -e "{{ ansible_user_dir }}/.zshrc" ]; then
      if zsh -c "source {{ ansible_user_dir }}/.zshrc && echo 'ZSH config loads successfully'" 2>/dev/null; then
        echo "‚úÖ ZSH configuration loads without errors"
      else
        echo "‚ö†Ô∏è  ZSH configuration has syntax errors or issues"
        warnings=$((warnings + 1))
      fi
    else
      echo "‚ùå Cannot test ZSH - .zshrc symlink missing or broken"
      critical_issues=$((critical_issues + 1))
      validation_passed=false
    fi

    # Summary
    echo ""
    echo "VALIDATION SUMMARY:"
    echo "=================="
    echo "Critical issues: $critical_issues"
    echo "Warnings: $warnings"
    echo "Overall status: $([ "$validation_passed" = true ] && echo "‚úÖ PASSED" || echo "‚ùå FAILED")"

    # Set validation status for Ansible
    if [ "$validation_passed" = true ]; then
      echo "VALIDATION_STATUS:PASSED"
    else
      echo "VALIDATION_STATUS:FAILED"
    fi

    echo "Critical issues count: $critical_issues"
    echo "Warnings count: $warnings"
  args:
    executable: /bin/bash
  register: final_validation
  when:
    - dotfiles_source_check.stat.exists
    - stow_check.rc == 0
  changed_when: false
  failed_when: false
  tags: ['dotfiles', 'validation', 'final']

- name: Set validation results
  set_fact:
    dotfiles_validation_passed: "{{ 'VALIDATION_STATUS:PASSED' in final_validation.stdout }}"
    dotfiles_critical_issues: "{{ final_validation.stdout_lines | select('match', '^Critical issues count:.*') | first | regex_replace('^Critical issues count: ', '') | int }}"
    dotfiles_warnings: "{{ final_validation.stdout_lines | select('match', '^Warnings count:.*') | first | regex_replace('^Warnings count: ', '') | int }}"
  when: final_validation is defined
  tags: ['dotfiles', 'validation']

# Error handling for missing requirements
- name: Display error if GNU Stow is missing
  debug:
    msg: |
      ‚ùå GNU Stow is required for dotfiles deployment but not found.

      Install GNU Stow:
      ‚Ä¢ macOS: brew install stow
      ‚Ä¢ Ubuntu/Debian: sudo apt install stow
      ‚Ä¢ Arch Linux: sudo pacman -S stow
      ‚Ä¢ CentOS/RHEL: sudo yum install stow
  when: stow_check.rc != 0
  tags: ['dotfiles', 'error']

- name: Display error if dotfiles directory is missing
  debug:
    msg: |
      ‚ùå Dotfiles directory not found: {{ dotfiles_path }}

      Ensure your dotfiles are structured for GNU Stow:
      {{ dotfiles_path }}/
      ‚îú‚îÄ‚îÄ zsh/
      ‚îÇ   ‚îî‚îÄ‚îÄ .zshrc
      ‚îú‚îÄ‚îÄ nvim/
      ‚îÇ   ‚îî‚îÄ‚îÄ .config/
      ‚îÇ       ‚îî‚îÄ‚îÄ nvim/
      ‚îî‚îÄ‚îÄ tmux/
          ‚îî‚îÄ‚îÄ .tmux.conf
  when: not dotfiles_source_check.stat.exists
  tags: ['dotfiles', 'error']
