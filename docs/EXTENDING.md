# Extending Dotsible

This guide covers how to extend Dotsible with new applications, operating systems, profiles, and custom functionality.

## Table of Contents

1. [Adding New Applications](#adding-new-applications)
2. [Adding Operating System Support](#adding-operating-system-support)
3. [Creating Custom Profiles](#creating-custom-profiles)
4. [Extending Package Management](#extending-package-management)
5. [Custom Roles and Tasks](#custom-roles-and-tasks)
6. [Advanced Customizations](#advanced-customizations)
7. [Contributing Back](#contributing-back)

## Adding New Applications

### Step 1: Create Application Role Structure

```bash
# Create the role directory structure
mkdir -p roles/applications/myapp/{tasks,vars,handlers,templates,files,meta}

# Create basic files
touch roles/applications/myapp/{tasks,vars,handlers,meta}/main.yml
```

### Step 2: Define Application Variables

```yaml
# roles/applications/myapp/vars/main.yml
---
myapp_version: "latest"
myapp_config_dir: "{{ ansible_env.HOME }}/.myapp"
myapp_packages:
  ubuntu:
    - myapp
    - myapp-dev
  archlinux:
    - myapp
    - myapp-devel
  macos:
    - myapp
  windows:
    - myapp

myapp_config:
  setting1: value1
  setting2: value2
  
myapp_aliases:
  ma: myapp
  myapp-status: "myapp --status"
```

### Step 3: Create Installation Tasks

```yaml
# roles/applications/myapp/tasks/main.yml
---
- name: Include OS-specific variables
  include_vars: "{{ ansible_os_family | lower }}.yml"
  failed_when: false

- name: Install MyApp packages
  package:
    name: "{{ myapp_packages[ansible_distribution | lower] | default(myapp_packages.default) }}"
    state: present
  become: yes
  when: myapp_packages[ansible_distribution | lower] is defined

- name: Create MyApp configuration directory
  file:
    path: "{{ myapp_config_dir }}"
    state: directory
    mode: '0755'

- name: Generate MyApp configuration
  template:
    src: myapp.conf.j2
    dest: "{{ myapp_config_dir }}/config"
    mode: '0644'
  notify: restart myapp

- name: Install MyApp from source (if needed)
  include_tasks: install_from_source.yml
  when: install_from_source | default(false)

- name: Setup MyApp aliases
  lineinfile:
    path: "{{ ansible_env.HOME }}/.bashrc"
    line: "alias {{ item.key }}='{{ item.value }}'"
    create: yes
  loop: "{{ myapp_aliases | dict2items }}"
  when: myapp_aliases is defined

- name: Verify MyApp installation
  command: myapp --version
  register: myapp_version_check
  changed_when: false
  failed_when: myapp_version_check.rc != 0

- name: Display MyApp version
  debug:
    msg: "MyApp {{ myapp_version_check.stdout }} installed successfully"
```

### Step 4: Create OS-Specific Variables

```yaml
# roles/applications/myapp/vars/ubuntu.yml
---
myapp_packages:
  - myapp
  - myapp-plugins
  - myapp-docs

myapp_service_name: myapp
myapp_config_path: /etc/myapp/myapp.conf
```

```yaml
# roles/applications/myapp/vars/archlinux.yml
---
myapp_packages:
  - myapp
  - myapp-git  # AUR package

myapp_service_name: myapp
myapp_config_path: /etc/myapp/myapp.conf
```

```yaml
# roles/applications/myapp/vars/darwin.yml
---
myapp_packages:
  - myapp

myapp_service_name: com.example.myapp
myapp_config_path: "{{ ansible_env.HOME }}/Library/Application Support/MyApp/config"
```

### Step 5: Create Configuration Templates

```jinja2
{# roles/applications/myapp/templates/myapp.conf.j2 #}
# MyApp Configuration
# Generated by Dotsible on {{ ansible_date_time.iso8601 }}

[general]
{% for key, value in myapp_config.items() %}
{{ key }} = {{ value }}
{% endfor %}

[system]
os = {{ ansible_distribution }}
arch = {{ ansible_architecture }}
user = {{ ansible_user_id }}

[paths]
config_dir = {{ myapp_config_dir }}
data_dir = {{ myapp_config_dir }}/data
log_dir = {{ myapp_config_dir }}/logs
```

### Step 6: Add Handlers

```yaml
# roles/applications/myapp/handlers/main.yml
---
- name: restart myapp
  service:
    name: "{{ myapp_service_name }}"
    state: restarted
  become: yes
  when: myapp_service_name is defined

- name: reload myapp config
  command: myapp --reload-config
  when: myapp_version_check is defined and myapp_version_check.rc == 0
```

### Step 7: Create Role Metadata

```yaml
# roles/applications/myapp/meta/main.yml
---
galaxy_info:
  author: Your Name
  description: MyApp installation and configuration
  company: Your Company
  license: MIT
  min_ansible_version: 2.9
  platforms:
    - name: Ubuntu
      versions:
        - focal
        - jammy
    - name: ArchLinux
      versions:
        - all
    - name: MacOSX
      versions:
        - all

dependencies:
  - role: common
  - role: package_manager

collections:
  - community.general
```

### Step 8: Add to Profiles

```yaml
# group_vars/all/profiles.yml
profiles:
  developer:
    applications:
      - git
      - vim
      - zsh
      - tmux
      - myapp  # Add your new application
    features:
      - advanced_shell
      - development_tools
      - myapp_integration
```

### Step 9: Update Main Playbook

```yaml
# site.yml (add to applications section)
- role: applications/myapp
  tags: ['applications', 'myapp']
  when: "'myapp' in profiles[profile | default('minimal')].applications"
```

### Step 10: Create Tests

```yaml
# tests/roles/test-myapp.yml
---
- name: Test MyApp Role Functionality
  hosts: all
  gather_facts: yes
  become: no
  
  tasks:
    - name: Include myapp role
      include_role:
        name: applications/myapp
    
    - name: Verify myapp installation
      command: myapp --version
      register: myapp_version_result
      changed_when: false
      failed_when: myapp_version_result.rc != 0
    
    - name: Check myapp configuration
      stat:
        path: "{{ ansible_env.HOME }}/.myapp/config"
      register: myapp_config_check
    
    - name: Verify configuration exists
      assert:
        that:
          - myapp_config_check.stat.exists
        fail_msg: "MyApp configuration not found"
        success_msg: "MyApp configuration verified"
```

## Adding Operating System Support

### Step 1: Create OS-Specific Group Variables

```yaml
# group_vars/fedora.yml
---
ansible_os_family: "RedHat"
package_manager: "dnf"

# Package manager configuration
package_manager_config:
  update_cache: true
  cache_valid_time: 3600

# OS-specific packages
essential_packages:
  - dnf-plugins-core
  - curl
  - wget
  - git
  - vim

development_packages:
  - gcc
  - gcc-c++
  - make
  - python3-devel
  - nodejs
  - npm

# Service management
service_manager: systemd
```

### Step 2: Update Package Manager Role

```yaml
# roles/package_manager/tasks/setup_dnf.yml
---
- name: Configure DNF repositories
  yum_repository:
    name: "{{ item.name }}"
    description: "{{ item.description }}"
    baseurl: "{{ item.baseurl }}"
    gpgcheck: "{{ item.gpgcheck | default('yes') }}"
    enabled: "{{ item.enabled | default('yes') }}"
  loop: "{{ dnf_repositories | default([]) }}"
  become: yes

- name: Update DNF cache
  dnf:
    update_cache: yes
  become: yes

- name: Install essential packages via DNF
  dnf:
    name: "{{ essential_packages }}"
    state: present
  become: yes
```

### Step 3: Add OS Detection Logic

```yaml
# roles/common/tasks/main.yml (add OS detection)
- name: Detect Fedora
  set_fact:
    detected_os: fedora
  when: 
    - ansible_distribution == "Fedora"
    - ansible_os_family == "RedHat"

- name: Include Fedora-specific tasks
  include_tasks: setup_fedora.yml
  when: detected_os == "fedora"
```

### Step 4: Update Application Roles

```yaml
# roles/applications/git/vars/fedora.yml
---
git_packages:
  - git
  - git-core
  - git-lfs

git_config_path: /etc/gitconfig
```

### Step 5: Add OS to Compatibility Matrix

```yaml
# group_vars/all/main.yml
os_compatibility:
  ubuntu: [minimal, developer, server, gaming]
  archlinux: [minimal, developer, server, gaming]
  macos: [minimal, developer, gaming]
  fedora: [minimal, developer, server]  # Add new OS
  windows: [minimal, developer]

profile_compatibility:
  minimal:
    ubuntu: true
    archlinux: true
    macos: true
    fedora: true  # Add compatibility
    windows: true
```

## Creating Custom Profiles

### Step 1: Define Profile Structure

```yaml
# group_vars/all/profiles.yml
profiles:
  data_scientist:
    description: "Data science and machine learning environment"
    applications:
      - git
      - vim
      - python3
      - jupyter
      - r-lang
      - docker
    features:
      - python_data_stack
      - r_environment
      - jupyter_lab
      - docker_support
    packages:
      - python3-pip
      - python3-venv
      - r-base
      - r-base-dev
    custom_config:
      jupyter_port: 8888
      r_mirror: "https://cran.rstudio.com/"
```

### Step 2: Create Profile Role

```bash
mkdir -p roles/profiles/data_scientist/{tasks,vars,handlers,templates,meta}
```

```yaml
# roles/profiles/data_scientist/tasks/main.yml
---
- name: Install Python data science packages
  pip:
    name: "{{ python_data_packages }}"
    state: present
    extra_args: --user

- name: Install R packages
  command: >
    Rscript -e "install.packages(c({{ r_packages | map('quote') | join(',') }}), 
    repos='{{ r_mirror }}')"
  changed_when: false

- name: Configure Jupyter Lab
  template:
    src: jupyter_lab_config.py.j2
    dest: "{{ ansible_env.HOME }}/.jupyter/jupyter_lab_config.py"
    mode: '0644'

- name: Create data science workspace
  file:
    path: "{{ ansible_env.HOME }}/workspace/{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - notebooks
    - datasets
    - projects
    - scripts
```

```yaml
# roles/profiles/data_scientist/vars/main.yml
---
python_data_packages:
  - numpy
  - pandas
  - matplotlib
  - seaborn
  - scikit-learn
  - jupyter
  - jupyterlab
  - ipython

r_packages:
  - "ggplot2"
  - "dplyr"
  - "tidyr"
  - "readr"
  - "caret"

r_mirror: "{{ custom_config.r_mirror | default('https://cran.rstudio.com/') }}"
jupyter_port: "{{ custom_config.jupyter_port | default(8888) }}"
```

### Step 3: Add Profile to Main Playbook

```yaml
# site.yml (add to profile section)
- role: profiles/data_scientist
  tags: ['profiles', 'data_scientist']
  when: profile == "data_scientist"
```

### Step 4: Create Profile Tests

```yaml
# tests/profiles/test-data-scientist.yml
---
- name: Test Data Scientist Profile
  hosts: all
  gather_facts: yes
  
  tasks:
    - name: Test Python packages
      command: python3 -c "import {{ item }}"
      loop:
        - numpy
        - pandas
        - matplotlib
        - sklearn
      changed_when: false
    
    - name: Test Jupyter installation
      command: jupyter --version
      register: jupyter_version
      changed_when: false
    
    - name: Test R installation
      command: R --version
      register: r_version
      changed_when: false
```

## Extending Package Management

### Step 1: Add New Package Manager Support

```yaml
# roles/package_manager/tasks/setup_zypper.yml (for openSUSE)
---
- name: Refresh zypper repositories
  zypper_repository:
    repo: "{{ item.repo }}"
    name: "{{ item.name }}"
    state: present
  loop: "{{ zypper_repositories | default([]) }}"
  become: yes

- name: Update package cache
  zypper:
    update_cache: yes
  become: yes

- name: Install essential packages
  zypper:
    name: "{{ essential_packages }}"
    state: present
  become: yes
```

### Step 2: Add Package Manager Detection

```yaml
# roles/package_manager/tasks/main.yml
- name: Detect package manager
  set_fact:
    package_manager: "{{ 'zypper' if ansible_os_family == 'Suse' else package_manager }}"

- name: Setup Zypper
  include_tasks: setup_zypper.yml
  when: package_manager == "zypper"
```

### Step 3: Create Package Definitions

```yaml
# group_vars/opensuse.yml
---
package_manager: zypper

essential_packages:
  - curl
  - wget
  - git
  - vim

development_packages:
  - gcc
  - gcc-c++
  - make
  - python3-devel
  - nodejs
  - npm
```

## Custom Roles and Tasks

### Creating Utility Roles

```yaml
# roles/utilities/system_info/tasks/main.yml
---
- name: Gather system information
  setup:
    gather_subset:
      - hardware
      - network
      - virtual

- name: Create system info report
  template:
    src: system_info.j2
    dest: "{{ ansible_env.HOME }}/.system_info"
    mode: '0644'

- name: Display system summary
  debug:
    msg: |
      System: {{ ansible_distribution }} {{ ansible_distribution_version }}
      Kernel: {{ ansible_kernel }}
      Memory: {{ ansible_memtotal_mb }}MB
      CPU: {{ ansible_processor_vcpus }} cores
```

### Creating Configuration Roles

```yaml
# roles/configurations/security_hardening/tasks/main.yml
---
- name: Configure SSH security
  lineinfile:
    path: /etc/ssh/sshd_config
    regexp: "{{ item.regexp }}"
    line: "{{ item.line }}"
    backup: yes
  loop:
    - { regexp: '^#?PermitRootLogin', line: 'PermitRootLogin no' }
    - { regexp: '^#?PasswordAuthentication', line: 'PasswordAuthentication no' }
    - { regexp: '^#?Port', line: 'Port {{ ssh_port | default(22) }}' }
  notify: restart ssh
  become: yes

- name: Configure firewall rules
  ufw:
    rule: "{{ item.rule }}"
    port: "{{ item.port }}"
    proto: "{{ item.proto | default('tcp') }}"
  loop: "{{ firewall_rules | default([]) }}"
  become: yes
```

## Advanced Customizations

### Custom Filters and Plugins

```python
# filter_plugins/custom_filters.py
def format_package_name(package_name, os_family):
    """Format package name based on OS family"""
    if os_family.lower() == 'debian':
        return package_name.replace('_', '-')
    elif os_family.lower() == 'redhat':
        return package_name.replace('-', '_')
    return package_name

class FilterModule(object):
    def filters(self):
        return {
            'format_package_name': format_package_name
        }
```

### Custom Modules

```python
# library/custom_package_manager.py
#!/usr/bin/python

from ansible.module_utils.basic import AnsibleModule

def main():
    module = AnsibleModule(
        argument_spec=dict(
            name=dict(required=True, type='str'),
            state=dict(default='present', choices=['present', 'absent']),
            manager=dict(required=True, choices=['apt', 'yum', 'pacman'])
        )
    )
    
    name = module.params['name']
    state = module.params['state']
    manager = module.params['manager']
    
    # Custom package management logic here
    
    module.exit_json(changed=True, msg=f"Package {name} {state}")

if __name__ == '__main__':
    main()
```

### Dynamic Inventory Scripts

```python
#!/usr/bin/env python3
# inventories/dynamic_inventory.py

import json
import sys

def get_inventory():
    inventory = {
        '_meta': {
            'hostvars': {}
        },
        'all': {
            'children': ['local', 'remote']
        },
        'local': {
            'hosts': ['localhost'],
            'vars': {
                'ansible_connection': 'local',
                'profile': 'developer'
            }
        },
        'remote': {
            'hosts': [],
            'vars': {
                'ansible_user': 'deploy'
            }
        }
    }
    
    # Add dynamic hosts based on environment
    # This could read from cloud APIs, databases, etc.
    
    return inventory

if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] == '--list':
        print(json.dumps(get_inventory(), indent=2))
    elif len(sys.argv) == 3 and sys.argv[1] == '--host':
        print(json.dumps({}))
    else:
        print("Usage: %s --list or %s --host <hostname>" % (sys.argv[0], sys.argv[0]))
```

## Contributing Back

### Preparing Contributions

1. **Fork the repository**
2. **Create a feature branch**
3. **Follow coding standards**
4. **Add tests**
5. **Update documentation**
6. **Submit pull request**

### Coding Standards

```yaml
# Follow YAML best practices
---
- name: Task description should be clear and descriptive
  module_name:
    parameter: value
    another_parameter: "{{ variable_name }}"
  when: condition_is_true
  tags: ['tag1', 'tag2']
  become: yes
```

### Testing Your Extensions

```bash
# Test syntax
ansible-playbook --syntax-check site.yml

# Test with check mode
ansible-playbook -i inventories/local/hosts.yml site.yml --check

# Run full test suite
./tests/scripts/run_all_tests.sh

# Test specific role
ansible-playbook -i tests/inventories/test.yml tests/roles/test-myapp.yml
```

### Documentation Requirements

1. **Update README.md** with new features
2. **Add role documentation** in role directories
3. **Update USAGE.md** with examples
4. **Add troubleshooting info** to TROUBLESHOOTING.md
5. **Include test procedures** in TESTING.md

### Example Pull Request Template

```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Syntax validation passes
- [ ] All tests pass
- [ ] Tested on multiple OS platforms
- [ ] Added new tests for new functionality

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] Tests added/updated
- [ ] No breaking changes (or clearly documented)
```

## Best Practices for Extensions

### 1. Modularity
- Keep roles focused on single responsibilities
- Use role dependencies appropriately
- Make roles reusable across different contexts

### 2. Cross-Platform Compatibility
- Test on all supported operating systems
- Use OS-specific variables and tasks
- Handle platform differences gracefully

### 3. Error Handling
- Use appropriate error handling mechanisms
- Provide meaningful error messages
- Implement rollback procedures where needed

### 4. Performance
- Minimize unnecessary tasks
- Use efficient Ansible modules
- Cache results when appropriate

### 5. Security
- Follow security best practices
- Validate inputs and outputs
- Use secure defaults

### 6. Documentation
- Document all variables and their purposes
- Provide usage examples
- Include troubleshooting information

---

**Happy Extending!** ðŸš€

For more information, see:
- [USAGE.md](USAGE.md) - Detailed usage guide
- [TESTING.md](TESTING.md) - Testing procedures
- [TROUBLESHOOTING.md](TROUBLESHOOTING.md) - Common issues and solutions