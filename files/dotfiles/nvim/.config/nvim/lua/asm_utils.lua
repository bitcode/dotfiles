-- Enhanced Assembly Development Utilities
-- Integrates GDB debugging and QEMU emulation
-- Generated by Ansible

local M = {}

-- Load integrations
local gdb_integration = require('gdb')
local qemu_integration = require('qemu')

-- Configuration
M.config = {
    supported_architectures = {
        "arm64", "arm32", "x86_64", "riscv64", "riscv32"
    },
    default_arch = "arm64",
    auto_detect = true,
    debug_port_base = 1234,
    examples_dir = vim.fn.expand("~/Development/assembly")
}

-- Architecture detection
function M.detect_architecture()
    local filename = vim.fn.expand("%:t")
    local filetype = vim.bo.filetype
    local content = table.concat(vim.api.nvim_buf_get_lines(0, 0, 50, false), "\n")
    
    -- Try filename patterns
    for _, arch in ipairs(M.config.supported_architectures) do
        if string.find(filename:lower(), arch) then
            return arch
        end
    end
    
    -- Try content analysis for assembly files
    if filetype == "asm" or filetype == "nasm" or filetype == "gas" or filetype == "s" then
        if string.find(content, "aarch64") or string.find(content, "arm64") then
            return "arm64"
        elseif string.find(content, "armv7") or string.find(content, "arm32") then
            return "arm32"
        elseif string.find(content, "x86_64") or string.find(content, "x64") then
            return "x86_64"
        elseif string.find(content, "riscv64") then
            return "riscv64"
        elseif string.find(content, "riscv32") or string.find(content, "riscv") then
            return "riscv32"
        end
        
        -- Check for architecture-specific instructions
        if string.find(content, "mov.*x[0-9]+") or string.find(content, "ldr.*x[0-9]+") then
            return "arm64"
        elseif string.find(content, "mov.*r[0-9]+") or string.find(content, "ldr.*r[0-9]+") then
            return "arm32"
        elseif string.find(content, "mov.*%rax") or string.find(content, "mov.*%eax") then
            return "x86_64"
        end
    end
    
    return M.config.default_arch
end

-- Get current file info
function M.get_file_info()
    local filepath = vim.fn.expand("%:p")
    local filename = vim.fn.expand("%:t")
    local filetype = vim.bo.filetype
    local arch = M.detect_architecture()
    
    return {
        filepath = filepath,
        filename = filename,
        filetype = filetype,
        architecture = arch,
        is_assembly = filetype == "asm" or filetype == "nasm" or filetype == "gas" or filetype == "s",
        directory = vim.fn.expand("%:p:h")
    }
end

-- Status command - shows comprehensive development environment status
function M.show_status()
    local file_info = M.get_file_info()
    local gdb_status = gdb_integration.get_gdb_status()
    local qemu_status = qemu_integration.get_qemu_status()
    
    print("Assembly Development Environment Status")
    print("=====================================")
    print("")
    
    -- File information
    print("Current File:")
    print("  Path: " .. file_info.filepath)
    print("  Type: " .. file_info.filetype)
    print("  Architecture: " .. file_info.architecture)
    print("  Is Assembly: " .. (file_info.is_assembly and "Yes" or "No"))
    print("")
    
    -- GDB Status
    print("GDB Debugger:")
    print("  Available: " .. (gdb_status.available and "✓" or "✗"))
    if gdb_status.available then
        print("  Version: " .. (gdb_status.version or "Unknown"))
        print("  Path: " .. (gdb_status.path or "Unknown"))
        print("  Multiarch: " .. (gdb_status.multiarch and "✓" or "✗"))
    end
    print("")
    
    -- QEMU Status
    print("QEMU Emulator:")
    print("  Available: " .. (qemu_status.available and "✓" or "✗"))
    if qemu_status.available then
        print("  System Emulators:")
        for arch, available in pairs(qemu_status.system_emulators) do
            print("    " .. arch .. ": " .. (available and "✓" or "✗"))
        end
        print("  User Emulators:")
        for arch, available in pairs(qemu_status.user_emulators) do
            print("    " .. arch .. ": " .. (available and "✓" or "✗"))
        end
    end
    print("")
    
    -- Integration Status
    print("Integration:")
    print("  Scripts Available: " .. (qemu_status.scripts and "✓" or "✗"))
    print("  Examples Directory: " .. M.config.examples_dir)
    print("  Supported Architectures: " .. table.concat(M.config.supported_architectures, ", "))
end

-- Debug command - start debugging session
function M.start_debug(arch)
    local file_info = M.get_file_info()
    arch = arch or file_info.architecture
    
    if not vim.tbl_contains(M.config.supported_architectures, arch) then
        print("Error: Unsupported architecture: " .. arch)
        return false
    end
    
    -- Check if we have a binary to debug
    local binary_path = nil
    local base_name = vim.fn.expand("%:t:r")
    
    -- Look for compiled binary
    local possible_binaries = {
        file_info.directory .. "/" .. base_name,
        file_info.directory .. "/" .. base_name .. ".out",
        file_info.directory .. "/" .. base_name .. ".elf",
        file_info.directory .. "/a.out"
    }
    
    for _, path in ipairs(possible_binaries) do
        if vim.fn.filereadable(path) == 1 then
            binary_path = path
            break
        end
    end
    
    if not binary_path then
        print("No binary found. Compile your assembly code first.")
        print("Looking for: " .. table.concat(possible_binaries, ", "))
        return false
    end
    
    print("Starting debug session for " .. arch .. " with binary: " .. binary_path)
    
    -- Use QEMU debugging for cross-architecture or GDB for native
    local current_arch = vim.fn.system("uname -m"):gsub("%s+", "")
    if arch == current_arch or (arch == "arm64" and current_arch == "aarch64") then
        -- Native debugging with GDB
        return gdb_integration.debug_binary(binary_path, {
            architecture = arch,
            auto_run = false
        })
    else
        -- Cross-architecture debugging with QEMU + GDB
        return qemu_integration.debug_qemu(arch, binary_path, {
            gdb = true,
            wait = true
        })
    end
end

-- Emulate command - run in QEMU emulator
function M.start_emulate(arch)
    local file_info = M.get_file_info()
    arch = arch or file_info.architecture
    
    if not vim.tbl_contains(M.config.supported_architectures, arch) then
        print("Error: Unsupported architecture: " .. arch)
        return false
    end
    
    -- Check if we have a binary to emulate
    local binary_path = nil
    local base_name = vim.fn.expand("%:t:r")
    
    -- Look for compiled binary
    local possible_binaries = {
        file_info.directory .. "/" .. base_name,
        file_info.directory .. "/" .. base_name .. ".out",
        file_info.directory .. "/" .. base_name .. ".elf",
        file_info.directory .. "/a.out"
    }
    
    for _, path in ipairs(possible_binaries) do
        if vim.fn.filereadable(path) == 1 then
            binary_path = path
            break
        end
    end
    
    if not binary_path then
        print("No binary found. Compile your assembly code first.")
        print("Looking for: " .. table.concat(possible_binaries, ", "))
        return false
    end
    
    print("Starting emulation for " .. arch .. " with binary: " .. binary_path)
    
    -- Use QEMU user mode emulation
    return qemu_integration.run_user_qemu(arch, binary_path)
end

-- QEMU command - launch QEMU system emulator
function M.launch_qemu(arch, options)
    arch = arch or M.detect_architecture()
    
    if not vim.tbl_contains(M.config.supported_architectures, arch) then
        print("Error: Unsupported architecture: " .. arch)
        return false
    end
    
    print("Launching QEMU system emulator for " .. arch)
    return qemu_integration.launch_qemu(arch, options or {})
end

-- Open examples
function M.open_examples(arch)
    arch = arch or M.detect_architecture()
    qemu_integration.open_examples(arch)
end

-- Setup commands
function M.setup_commands()
    -- Status command
    vim.api.nvim_create_user_command('AsmStatus', function()
        M.show_status()
    end, { desc = 'Show assembly development environment status' })
    
    -- Debug commands
    vim.api.nvim_create_user_command('AsmDebug', function(opts)
        M.start_debug(opts.args ~= "" and opts.args or nil)
    end, { 
        nargs = '?',
        complete = function()
            return M.config.supported_architectures
        end,
        desc = 'Start debugging session for specified architecture'
    })
    
    -- Emulate commands
    vim.api.nvim_create_user_command('AsmEmulate', function(opts)
        M.start_emulate(opts.args ~= "" and opts.args or nil)
    end, { 
        nargs = '?',
        complete = function()
            return M.config.supported_architectures
        end,
        desc = 'Start emulation for specified architecture'
    })
    
    -- QEMU commands
    vim.api.nvim_create_user_command('AsmQEMU', function(opts)
        M.launch_qemu(opts.args ~= "" and opts.args or nil)
    end, { 
        nargs = '?',
        complete = function()
            return M.config.supported_architectures
        end,
        desc = 'Launch QEMU system emulator for specified architecture'
    })
    
    -- Examples command
    vim.api.nvim_create_user_command('AsmExamples', function(opts)
        M.open_examples(opts.args ~= "" and opts.args or nil)
    end, { 
        nargs = '?',
        complete = function()
            return M.config.supported_architectures
        end,
        desc = 'Open assembly examples for specified architecture'
    })
end

-- Initialize
function M.setup()
    M.setup_commands()
    
    -- Auto-detect architecture on assembly file open
    vim.api.nvim_create_autocmd({"BufRead", "BufNewFile"}, {
        pattern = {"*.s", "*.S", "*.asm", "*.nasm"},
        callback = function()
            local arch = M.detect_architecture()
            vim.b.detected_architecture = arch
            print("Detected architecture: " .. arch)
        end
    })
end

return M